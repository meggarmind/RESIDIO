'use server';

import { createServerSupabaseClient } from '@/lib/supabase/server';
import { revalidatePath } from 'next/cache';
import type { Resident, ResidentRole } from '@/types/database';
import { z } from 'zod';
import { logAudit } from '@/lib/audit/logger';

/**
 * Secondary/household roles that primary residents can add
 * - household_member: Family members, dependents living in the house
 * - domestic_staff: Domestic workers (needs sponsor)
 * - caretaker: Assigned to maintain the unit
 */
const ALLOWED_HOUSEHOLD_ROLES: ResidentRole[] = ['household_member', 'domestic_staff', 'caretaker'];

// Input validation schema
const HouseholdMemberSchema = z.object({
  first_name: z.string().min(1, 'First name is required'),
  last_name: z.string().min(1, 'Last name is required'),
  phone_primary: z.string().optional(),
  email: z.string().email('Invalid email address').optional().or(z.literal('')),
  resident_role: z.enum(['household_member', 'domestic_staff', 'caretaker']),
  house_id: z.string().uuid('Invalid house ID'),
  relationship: z.string().optional(), // e.g., "Spouse", "Child", "Driver"
  send_portal_invite: z.boolean().optional(), // Whether to send portal invitation email
});

export type HouseholdMemberInput = z.infer<typeof HouseholdMemberSchema>;

type AddHouseholdMemberResponse = {
  data: Resident | null;
  error: string | null;
};

/**
 * Add a household member to a property
 *
 * This action allows primary residents (those with is_primary=true for a house)
 * to add secondary residents like household members, contractors, or domestic staff.
 *
 * Security:
 * - Validates caller is the primary resident for the target house
 * - Only allows secondary roles (not landlord, tenant, etc.)
 * - Creates audit trail via created_by field
 */
export async function addHouseholdMember(
  input: HouseholdMemberInput
): Promise<AddHouseholdMemberResponse> {
  const supabase = await createServerSupabaseClient();

  // Get current user
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) {
    return { data: null, error: 'Unauthorized - please sign in' };
  }

  // Validate input
  const parsed = HouseholdMemberSchema.safeParse(input);
  if (!parsed.success) {
    return { data: null, error: parsed.error.issues[0].message };
  }

  const { first_name, last_name, phone_primary, email, resident_role, house_id, relationship, send_portal_invite } = parsed.data;

  // Validate role is allowed
  if (!ALLOWED_HOUSEHOLD_ROLES.includes(resident_role)) {
    return { data: null, error: 'Invalid role. Only household members, contractors, and domestic staff can be added.' };
  }

  // Get caller's profile to find their resident_id
  const { data: profile, error: profileError } = await supabase
    .from('profiles')
    .select('resident_id')
    .eq('id', user.id)
    .single();

  if (profileError || !profile?.resident_id) {
    return { data: null, error: 'Could not find your resident profile' };
  }

  // Verify caller is the PRIMARY resident for this house
  const { data: primaryCheck, error: primaryError } = await supabase
    .from('resident_houses')
    .select('id, is_primary')
    .eq('resident_id', profile.resident_id)
    .eq('house_id', house_id)
    .eq('is_active', true)
    .single();

  if (primaryError || !primaryCheck) {
    return { data: null, error: 'You are not assigned to this property' };
  }

  if (!primaryCheck.is_primary) {
    return { data: null, error: 'Only primary residents can add household members' };
  }

  // Create the new resident (resident_code is auto-generated by database trigger)
  const { data: newResident, error: createError } = await supabase
    .from('residents')
    .insert({
      first_name,
      last_name,
      phone_primary: phone_primary || null,
      email: email || null,
      resident_type: 'resident', // Default type
      verification_status: 'verified', // Auto-verify when added by primary resident
      entity_type: 'individual',
      notes: relationship ? `Relationship: ${relationship}` : null,
      created_by: user.id,
      updated_by: user.id,
    })
    .select()
    .single();

  if (createError) {
    return { data: null, error: `Failed to create resident: ${createError.message}` };
  }

  // Create house assignment with is_primary = false
  const { error: assignmentError } = await supabase
    .from('resident_houses')
    .insert({
      resident_id: newResident.id,
      house_id,
      resident_role,
      is_primary: false, // Secondary resident
      move_in_date: new Date().toISOString().split('T')[0],
      sponsor_resident_id: resident_role === 'domestic_staff' ? profile.resident_id : null,
      created_by: user.id,
    });

  if (assignmentError) {
    // Rollback: delete resident if house assignment fails
    await supabase.from('residents').delete().eq('id', newResident.id);
    return { data: null, error: `Failed to assign to house: ${assignmentError.message}` };
  }

  // Send portal invitation email if requested
  if (send_portal_invite && email) {
    // TODO: Implement email invitation system
    // For now, we'll log the intent and store it for future implementation
    // This would typically:
    // 1. Generate a unique invitation token
    // 2. Store the invitation in a pending_invitations table
    // 3. Send an email with a signup link containing the token
    // 4. When they sign up, link their auth user to this resident record
    console.log(`Portal invitation requested for ${email} (resident: ${newResident.id})`);

    // Create a pending invitation record (if table exists)
    // await supabase.from('pending_invitations').insert({
    //   resident_id: newResident.id,
    //   email,
    //   invited_by: user.id,
    //   house_id,
    //   expires_at: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(), // 7 days
    // });
  }

  // Audit log (portal action by primary resident)
  await logAudit({
    action: 'CREATE',
    entityType: 'residents',
    entityId: newResident.id,
    entityDisplay: `${newResident.first_name} ${newResident.last_name} (${newResident.resident_code})`,
    newValues: {
      name: `${first_name} ${last_name}`,
      resident_role,
      house_id,
      relationship: relationship || null,
      added_by_primary_resident: profile.resident_id,
    },
    description: `Household member added via portal by primary resident`,
  });

  // Revalidate relevant paths
  revalidatePath('/portal/profile');
  revalidatePath('/residents');
  revalidatePath(`/portal/properties/${house_id}`);

  return { data: newResident, error: null };
}

// Type for household member query result
export type HouseholdMember = {
  id: string;
  resident_role: ResidentRole;
  is_primary: boolean;
  move_in_date: string;
  resident: {
    id: string;
    first_name: string;
    last_name: string;
    phone_primary: string | null;
    resident_code: string;
    notes: string | null;
  } | null;
};

/**
 * Get household members for a specific house
 * Returns all secondary residents linked to the house
 */
export async function getHouseholdMembers(houseId: string): Promise<{
  data: HouseholdMember[] | null;
  error: string | null;
}> {
  const supabase = await createServerSupabaseClient();

  const { data, error } = await supabase
    .from('resident_houses')
    .select(`
      id,
      resident_role,
      is_primary,
      move_in_date,
      resident:residents (
        id,
        first_name,
        last_name,
        phone_primary,
        resident_code,
        notes
      )
    `)
    .eq('house_id', houseId)
    .eq('is_active', true)
    .eq('is_primary', false)
    .in('resident_role', ALLOWED_HOUSEHOLD_ROLES);

  if (error) {
    return { data: null, error: error.message };
  }

  // Transform the data to match expected type (Supabase returns single object for 1:1 relations)
  const transformedData = (data || []).map(item => ({
    ...item,
    resident: Array.isArray(item.resident) ? item.resident[0] || null : item.resident,
  })) as HouseholdMember[];

  return { data: transformedData, error: null };
}

/**
 * Remove a household member from a house
 * Only the primary resident can remove household members
 */
export async function removeHouseholdMember(
  residentHouseId: string
): Promise<{ success: boolean; error: string | null }> {
  const supabase = await createServerSupabaseClient();

  // Get current user
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: 'Unauthorized' };
  }

  // Get the resident_house record to find the house_id
  const { data: targetRecord, error: fetchError } = await supabase
    .from('resident_houses')
    .select('id, house_id, is_primary, resident_role')
    .eq('id', residentHouseId)
    .single();

  if (fetchError || !targetRecord) {
    return { success: false, error: 'Household member not found' };
  }

  // Prevent removing primary residents
  if (targetRecord.is_primary) {
    return { success: false, error: 'Cannot remove primary resident' };
  }

  // Verify caller is primary resident for this house
  const { data: profile } = await supabase
    .from('profiles')
    .select('resident_id')
    .eq('id', user.id)
    .single();

  if (!profile?.resident_id) {
    return { success: false, error: 'Could not verify your identity' };
  }

  const { data: isPrimary } = await supabase
    .from('resident_houses')
    .select('is_primary')
    .eq('resident_id', profile.resident_id)
    .eq('house_id', targetRecord.house_id)
    .eq('is_active', true)
    .eq('is_primary', true)
    .single();

  if (!isPrimary) {
    return { success: false, error: 'Only primary residents can remove household members' };
  }

  // Get resident info for audit log before deactivation
  const { data: residentInfo } = await supabase
    .from('resident_houses')
    .select('resident:residents(id, first_name, last_name, resident_code)')
    .eq('id', residentHouseId)
    .single();

  // Deactivate the house assignment (soft delete)
  const { error: updateError } = await supabase
    .from('resident_houses')
    .update({
      is_active: false,
      move_out_date: new Date().toISOString().split('T')[0],
      updated_by: user.id,
    })
    .eq('id', residentHouseId);

  if (updateError) {
    return { success: false, error: updateError.message };
  }

  // Audit log (portal action by primary resident)
  // Handle Supabase returning array or single object for nested select
  const residentRaw = residentInfo?.resident;
  const residentData = Array.isArray(residentRaw) ? residentRaw[0] : residentRaw;
  if (residentData) {
    await logAudit({
      action: 'DELETE',
      entityType: 'resident_houses',
      entityId: residentHouseId,
      entityDisplay: `${residentData.first_name} ${residentData.last_name} (${residentData.resident_code})`,
      oldValues: {
        resident_id: residentData.id,
        house_id: targetRecord.house_id,
        resident_role: targetRecord.resident_role,
        is_active: true,
      },
      newValues: {
        is_active: false,
        move_out_date: new Date().toISOString().split('T')[0],
      },
      description: `Household member removed via portal by primary resident`,
    });
  }

  revalidatePath('/portal/profile');
  return { success: true, error: null };
}
