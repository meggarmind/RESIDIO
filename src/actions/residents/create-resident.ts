'use server';

import { createServerSupabaseClient, createAdminClient } from '@/lib/supabase/server';
import { revalidatePath } from 'next/cache';
import type { Resident, ResidentRole } from '@/types/database';
import type { CreateResidentData } from '@/lib/validators/resident';
import { requiresSponsor, isValidCorporateRole } from '@/lib/validators/resident';
import { RESIDENT_ROLE_LABELS } from '@/types/database';
import { sendWelcomeEmail } from '@/actions/email/send-welcome-email';
import { sendEmailVerification, sendPhoneVerification } from '@/actions/verification/send-verification';
import { authorizePermission } from '@/lib/auth/authorize';
import { PERMISSIONS } from '@/lib/auth/action-roles';
import { logAudit } from '@/lib/audit/logger';

type CreateResidentResponse = {
  data: Resident | null;
  error: string | null;
}

export async function createResident(formData: CreateResidentData): Promise<CreateResidentResponse> {
  // Permission check
  const auth = await authorizePermission(PERMISSIONS.RESIDENTS_CREATE);
  if (!auth.authorized) {
    return { data: null, error: auth.error || 'Unauthorized' };
  }

  const supabase = await createServerSupabaseClient();

  const { data: { user } } = await supabase.auth.getUser();
  if (!user) {
    return { data: null, error: 'Unauthorized' };
  }

  // Create resident (resident_code is auto-generated by trigger)
  const { data: resident, error: residentError } = await supabase
    .from('residents')
    .insert({
      first_name: formData.first_name,
      last_name: formData.last_name,
      email: formData.email || null,
      phone_primary: formData.phone_primary,
      phone_secondary: formData.phone_secondary || null,
      resident_type: formData.resident_type,
      verification_status: 'verified', // Auto-verify residents added by admins
      // Entity type fields
      entity_type: formData.entity_type || 'individual',
      company_name: formData.company_name || null,
      rc_number: formData.rc_number || null,
      liaison_contact_name: formData.liaison_contact_name || null,
      liaison_contact_phone: formData.liaison_contact_phone || null,
      // Emergency contact
      emergency_contact_name: formData.emergency_contact_name || null,
      emergency_contact_phone: formData.emergency_contact_phone || null,
      emergency_contact_relationship: formData.emergency_contact_relationship || null,
      notes: formData.notes || null,
      created_by: user.id,
      updated_by: user.id,
    })
    .select()
    .single();

  if (residentError) {
    return { data: null, error: residentError.message };
  }

  // Create house assignment if provided
  if (formData.house_id && formData.resident_role) {
    const role = formData.resident_role as ResidentRole;
    const entityType = formData.entity_type || 'individual';

    // Validate corporate role restriction
    if (entityType === 'corporate' && !isValidCorporateRole(role)) {
      await supabase.from('residents').delete().eq('id', resident.id);
      return {
        data: null,
        error: 'Corporate entities can only be Non-Resident Landlord or Developer',
      };
    }

    // Validate sponsor requirement for domestic_staff and caretaker
    if (requiresSponsor(role) && !formData.sponsor_resident_id) {
      await supabase.from('residents').delete().eq('id', resident.id);
      return {
        data: null,
        error: `${RESIDENT_ROLE_LABELS[role]} must have a sponsor. Please select a sponsor.`,
      };
    }

    // Check for unit occupancy conflicts (handled by database triggers, but provide better error messages)
    // resident_landlord and tenant are mutually exclusive per house
    if (role === 'resident_landlord' || role === 'tenant') {
      const { data: existingRole } = await supabase
        .from('resident_houses')
        .select('id, resident_role, resident:residents(first_name, last_name)')
        .eq('house_id', formData.house_id)
        .in('resident_role', ['resident_landlord', 'tenant'])
        .eq('is_active', true)
        .single();

      if (existingRole) {
        await supabase.from('residents').delete().eq('id', resident.id);
        const residentData = existingRole.resident as unknown as { first_name: string; last_name: string } | null;
        const existingName = residentData
          ? `${residentData.first_name} ${residentData.last_name}`
          : 'another resident';
        const existingRoleLabel = RESIDENT_ROLE_LABELS[existingRole.resident_role as ResidentRole];

        if (existingRole.resident_role === role) {
          return {
            data: null,
            error: `This house already has an active ${existingRoleLabel} (${existingName}). Please unassign them first.`,
          };
        } else {
          return {
            data: null,
            error: `This house already has an ${existingRoleLabel} (${existingName}). Cannot have both Resident Landlord and Tenant in the same unit.`,
          };
        }
      }
    }

    const { error: assignmentError } = await supabase
      .from('resident_houses')
      .insert({
        resident_id: resident.id,
        house_id: formData.house_id,
        resident_role: formData.resident_role,
        move_in_date: formData.move_in_date || new Date().toISOString().split('T')[0],
        sponsor_resident_id: formData.sponsor_resident_id || null,
        created_by: user.id,
      });

    if (assignmentError) {
      // Rollback: delete resident if house assignment fails
      await supabase.from('residents').delete().eq('id', resident.id);
      return { data: null, error: `Failed to assign house: ${assignmentError.message}` };
    }
  }

  // Send welcome email and verification codes if resident has email/phone (non-blocking)
  // These run in parallel for better performance
  const notifications: Promise<unknown>[] = [];

  if (resident.email) {
    // Send welcome email
    notifications.push(
      sendWelcomeEmail(resident.id).catch((err) => {
        console.error(`[Resident] Failed to send welcome email for ${resident.resident_code}:`, err);
      })
    );

    // Send email verification code
    notifications.push(
      sendEmailVerification(resident.id).catch((err) => {
        console.error(`[Resident] Failed to send email verification for ${resident.resident_code}:`, err);
      })
    );
  }

  // Send phone verification code (SMS)
  if (resident.phone_primary) {
    notifications.push(
      sendPhoneVerification(resident.id).catch((err) => {
        console.error(`[Resident] Failed to send phone verification for ${resident.resident_code}:`, err);
      })
    );
  }

  // Wait for all notifications to complete (or fail gracefully)
  await Promise.allSettled(notifications);

  // Audit log
  await logAudit({
    action: 'CREATE',
    entityType: 'residents',
    entityId: resident.id,
    entityDisplay: `${resident.first_name} ${resident.last_name} (${resident.resident_code})`,
    newValues: {
      name: `${resident.first_name} ${resident.last_name}`,
      resident_type: formData.resident_type,
      entity_type: formData.entity_type || 'individual',
      email: formData.email || null,
      phone: formData.phone_primary,
      house_id: formData.house_id || null,
      resident_role: formData.resident_role || null,
    },
    description: formData.house_id
      ? `Created resident with house assignment`
      : `Created resident`,
  });

  revalidatePath('/residents');
  revalidatePath('/houses');
  return { data: resident, error: null };
}
