'use server';

import { createServerSupabaseClient } from '@/lib/supabase/server';
import { revalidatePath } from 'next/cache';
import type { AccessCode, AccessCodeWithContact } from '@/types/database';
import type { CreateAccessCodeData, RevokeAccessCodeData, VerifyAccessCodeData } from '@/lib/validators/security-contact';
import { hasSecurityPermission } from './settings';
import { logAudit } from '@/lib/audit/logger';
import { formatDateTime } from '@/lib/utils';

type AccessCodeResponse = {
  data: AccessCode | null;
  error: string | null;
}

type AccessCodesResponse = {
  data: AccessCode[];
  error: string | null;
}

type VerifyCodeResponse = {
  data: AccessCodeWithContact | null;
  valid: boolean;
  error: string | null;
  reason?: string;
}

/**
 * Generates a new access code for a security contact
 */
export async function generateAccessCode(
  data: CreateAccessCodeData
): Promise<AccessCodeResponse> {
  const supabase = await createServerSupabaseClient();

  // Check permission
  const canGenerate = await hasSecurityPermission('generate_codes');
  if (!canGenerate) {
    return { data: null, error: 'Permission denied: Cannot generate access codes' };
  }

  // Get current user
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) {
    return { data: null, error: 'Unauthorized' };
  }

  // Verify contact exists and is active
  const { data: contact, error: contactError } = await supabase
    .from('security_contacts')
    .select('id, full_name, status, resident:residents(first_name, last_name), category:security_contact_categories(name, default_validity_days)')
    .eq('id', data.contact_id)
    .single();

  if (contactError || !contact) {
    return { data: null, error: 'Security contact not found' };
  }

  if (contact.status !== 'active') {
    return { data: null, error: 'Cannot generate code for inactive contact' };
  }

  // Calculate validity period
  const categoryData = contact.category as unknown as { default_validity_days: number };
  const validityDays = data.validity_days || categoryData?.default_validity_days || 30;

  const validFrom = data.valid_from ? new Date(data.valid_from) : new Date();
  const validUntil = data.valid_until
    ? new Date(data.valid_until)
    : new Date(validFrom.getTime() + validityDays * 24 * 60 * 60 * 1000);

  // Set max_uses based on code type
  let maxUses: number | null = null;
  if (data.code_type === 'one_time') {
    maxUses = 1;
  } else if (data.max_uses) {
    maxUses = data.max_uses;
  }

  // Create the access code (code is auto-generated by trigger)
  const { data: accessCode, error: createError } = await supabase
    .from('access_codes')
    .insert({
      contact_id: data.contact_id,
      code_type: data.code_type,
      valid_from: validFrom.toISOString(),
      valid_until: validUntil.toISOString(),
      max_uses: maxUses,
      is_active: true,
    })
    .select()
    .single();

  if (createError) {
    console.error('Generate access code error:', createError);
    return { data: null, error: 'Failed to generate access code' };
  }

  // Audit log
  const residentData = contact.resident as unknown as { first_name: string; last_name: string } | null;
  const categoryName = (contact.category as unknown as { name: string })?.name || 'Unknown';
  await logAudit({
    action: 'GENERATE',
    entityType: 'access_codes',
    entityId: accessCode.id,
    entityDisplay: `${accessCode.code} for ${contact.full_name} (${categoryName} - ${residentData?.first_name || ''} ${residentData?.last_name || ''})`,
    newValues: accessCode,
  });

  revalidatePath('/security');
  revalidatePath('/security/contacts');
  revalidatePath(`/security/contacts/${data.contact_id}`);

  return { data: accessCode, error: null };
}

/**
 * Gets all access codes for a contact
 */
export async function getContactAccessCodes(contactId: string): Promise<AccessCodesResponse> {
  const supabase = await createServerSupabaseClient();

  // Check permission
  const canView = await hasSecurityPermission('view_contacts');
  if (!canView) {
    return { data: [], error: 'Permission denied' };
  }

  const { data, error } = await supabase
    .from('access_codes')
    .select('*')
    .eq('contact_id', contactId)
    .order('created_at', { ascending: false });

  if (error) {
    console.error('Get contact access codes error:', error);
    return { data: [], error: 'Failed to fetch access codes' };
  }

  return { data: data || [], error: null };
}

/**
 * Regenerates an access code (revokes old, creates new)
 */
export async function regenerateAccessCode(codeId: string): Promise<AccessCodeResponse> {
  const supabase = await createServerSupabaseClient();

  // Check permission
  const canGenerate = await hasSecurityPermission('generate_codes');
  if (!canGenerate) {
    return { data: null, error: 'Permission denied: Cannot generate access codes' };
  }

  // Get current user
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) {
    return { data: null, error: 'Unauthorized' };
  }

  // Get existing code
  const { data: existingCode, error: fetchError } = await supabase
    .from('access_codes')
    .select('*, contact:security_contacts(id, full_name, status)')
    .eq('id', codeId)
    .single();

  if (fetchError || !existingCode) {
    return { data: null, error: 'Access code not found' };
  }

  const contactData = existingCode.contact as unknown as { id: string; full_name: string; status: string } | null;
  if (!contactData || contactData.status !== 'active') {
    return { data: null, error: 'Cannot regenerate code for inactive contact' };
  }

  // Revoke the old code
  await supabase
    .from('access_codes')
    .update({
      is_active: false,
      revoked_at: new Date().toISOString(),
      revoked_by: user.id,
    })
    .eq('id', codeId);

  // Create new code with same settings
  const { data: newCode, error: createError } = await supabase
    .from('access_codes')
    .insert({
      contact_id: existingCode.contact_id,
      code_type: existingCode.code_type,
      valid_from: new Date().toISOString(),
      valid_until: existingCode.valid_until,
      max_uses: existingCode.max_uses,
      is_active: true,
    })
    .select()
    .single();

  if (createError) {
    console.error('Regenerate access code error:', createError);
    return { data: null, error: 'Failed to regenerate access code' };
  }

  // Audit log
  await logAudit({
    action: 'GENERATE',
    entityType: 'access_codes',
    entityId: newCode.id,
    entityDisplay: `${newCode.code} (regenerated from ${existingCode.code}) for ${contactData.full_name}`,
    oldValues: { old_code: existingCode.code, old_code_id: existingCode.id },
    newValues: newCode,
  });

  revalidatePath('/security');
  revalidatePath('/security/contacts');

  return { data: newCode, error: null };
}

/**
 * Revokes an access code
 */
export async function revokeAccessCode(data: RevokeAccessCodeData): Promise<{ success: boolean; error: string | null }> {
  const supabase = await createServerSupabaseClient();

  // Check permission
  const canRevoke = await hasSecurityPermission('suspend_revoke_contacts');
  if (!canRevoke) {
    return { success: false, error: 'Permission denied' };
  }

  // Get current user
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) {
    return { success: false, error: 'Unauthorized' };
  }

  // Get existing code for audit
  const { data: existingCode, error: fetchError } = await supabase
    .from('access_codes')
    .select('*, contact:security_contacts(full_name)')
    .eq('id', data.code_id)
    .single();

  if (fetchError || !existingCode) {
    return { success: false, error: 'Access code not found' };
  }

  // Revoke the code
  const { error: updateError } = await supabase
    .from('access_codes')
    .update({
      is_active: false,
      revoked_at: new Date().toISOString(),
      revoked_by: user.id,
    })
    .eq('id', data.code_id);

  if (updateError) {
    console.error('Revoke access code error:', updateError);
    return { success: false, error: 'Failed to revoke access code' };
  }

  // Audit log
  const contactData = existingCode.contact as unknown as { full_name: string } | null;
  await logAudit({
    action: 'DEACTIVATE',
    entityType: 'access_codes',
    entityId: data.code_id,
    entityDisplay: `${existingCode.code} for ${contactData?.full_name || 'Unknown'}`,
    oldValues: { is_active: true },
    newValues: { is_active: false, reason: data.reason },
  });

  revalidatePath('/security');
  revalidatePath('/security/contacts');

  return { success: true, error: null };
}

/**
 * Verifies an access code and returns contact information
 * This is the main function used by security officers at the gate
 */
export async function verifyAccessCode(data: VerifyAccessCodeData): Promise<VerifyCodeResponse> {
  const supabase = await createServerSupabaseClient();

  // Check permission
  const canVerify = await hasSecurityPermission('verify_codes');
  if (!canVerify) {
    return { data: null, valid: false, error: 'Permission denied' };
  }

  const code = data.code.toUpperCase().trim();

  // Look up the access code with contact and resident information
  const { data: accessCode, error: fetchError } = await supabase
    .from('access_codes')
    .select(`
      *,
      contact:security_contacts(
        *,
        category:security_contact_categories(*),
        resident:residents(id, first_name, last_name, resident_code, phone_primary)
      )
    `)
    .eq('code', code)
    .single();

  if (fetchError || !accessCode) {
    return {
      data: null,
      valid: false,
      error: null,
      reason: 'Access code not found'
    };
  }

  const now = new Date();
  const validFrom = new Date(accessCode.valid_from);
  const validUntil = accessCode.valid_until ? new Date(accessCode.valid_until) : null;
  const contactData = accessCode.contact as unknown as {
    status: string;
    full_name: string;
  };

  // Check if code is active
  if (!accessCode.is_active) {
    return {
      data: accessCode as unknown as AccessCodeWithContact,
      valid: false,
      error: null,
      reason: 'Access code has been revoked',
    };
  }

  // Check if contact is active
  if (contactData.status !== 'active') {
    return {
      data: accessCode as unknown as AccessCodeWithContact,
      valid: false,
      error: null,
      reason: `Contact status: ${contactData.status}`,
    };
  }

  // Check validity period
  if (now < validFrom) {
    return {
      data: accessCode as unknown as AccessCodeWithContact,
      valid: false,
      error: null,
      reason: `Code not yet valid. Valid from: ${formatDateTime(validFrom)}`,
    };
  }

  if (validUntil && now > validUntil) {
    return {
      data: accessCode as unknown as AccessCodeWithContact,
      valid: false,
      error: null,
      reason: `Code expired on ${formatDateTime(validUntil)}`,
    };
  }

  // Check max uses for one-time codes
  if (accessCode.max_uses !== null && accessCode.current_uses >= accessCode.max_uses) {
    return {
      data: accessCode as unknown as AccessCodeWithContact,
      valid: false,
      error: null,
      reason: 'Maximum uses exceeded',
    };
  }

  // Code is valid
  return {
    data: accessCode as unknown as AccessCodeWithContact,
    valid: true,
    error: null,
  };
}

/**
 * Gets an access code by its code string (for lookup)
 */
export async function getAccessCodeByCode(code: string): Promise<AccessCodeResponse> {
  const supabase = await createServerSupabaseClient();

  // Check permission
  const canView = await hasSecurityPermission('view_contacts');
  if (!canView) {
    return { data: null, error: 'Permission denied' };
  }

  const { data, error } = await supabase
    .from('access_codes')
    .select('*')
    .eq('code', code.toUpperCase().trim())
    .single();

  if (error) {
    return { data: null, error: 'Access code not found' };
  }

  return { data, error: null };
}

/**
 * Deactivates all expired codes (called by cron or manually)
 */
export async function deactivateExpiredCodes(): Promise<{ count: number; error: string | null }> {
  const supabase = await createServerSupabaseClient();

  const { data, error } = await supabase
    .from('access_codes')
    .update({ is_active: false })
    .eq('is_active', true)
    .lt('valid_until', new Date().toISOString())
    .select('id');

  if (error) {
    console.error('Deactivate expired codes error:', error);
    return { count: 0, error: 'Failed to deactivate expired codes' };
  }

  return { count: data?.length || 0, error: null };
}
